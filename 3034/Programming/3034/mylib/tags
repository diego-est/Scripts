!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Sh	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!Sh	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Sh	h,heredoc	/label for here document/
!_TAG_KIND_DESCRIPTION!Sh	s,script	/script files/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PARSER_VERSION!Sh	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/Michorron/Scripts/3034/mylib/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	/p6.0.20221218.0/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
!_TAG_ROLE_DESCRIPTION!Sh!heredoc	endmarker	/end marker/
!_TAG_ROLE_DESCRIPTION!Sh!script	loaded	/loaded/
BUILD	unit_tests/Makefile	/^BUILD=.\/build$/;"	m
BinaryNode	binary_node.hpp	/^struct BinaryNode {$/;"	s
BinaryNode	binary_node_impl.hpp	/^BinaryNode<T>::BinaryNode(const T data, ptr<BinaryNode> left, ptr<BinaryNode> right)$/;"	f	class:BinaryNode
CXX	unit_tests/Makefile	/^CXX=clang++$/;"	m
CXXFLAGS	unit_tests/Makefile	/^CXXFLAGS=-Weverything -Werror -Wconversion --std=c++20 -Wno-c++98-compat -Wno-padded -Wno-docume/;"	m
Circle	circle.hpp	/^class Circle {$/;"	c
Circle	src/circle.cpp	/^Circle::Circle(double radius) :m_radius(radius)$/;"	f	class:Circle
Cylinder	cylinder.hpp	/^class Cylinder : public Circle {$/;"	c
Cylinder	src/cylinder.cpp	/^Cylinder::Cylinder(double radius, double height) : Circle(radius), m_height(height)$/;"	f	class:Cylinder
List	list.hpp	/^class List {$/;"	c
List	src/list.cpp	/^List::List() : m_head(nullptr), m_size(0lu)$/;"	f	class:List
List	src/list.cpp	/^List::List(const List& l) : m_head(nullptr), m_size(l.m_size)$/;"	f	class:List
NOTEST	unit_tests/unit_tests.cpp	/^#define NOTEST$/;"	d	file:
Node	node.hpp	/^	Node(int data, pointer<Node> ptr = nullptr) : link(ptr), info(data)$/;"	f	struct:Node
Node	node.hpp	/^struct Node {$/;"	s
Queue	queue.hpp	/^class Queue : public List {$/;"	c
Queue	src/queue.cpp	/^Queue::Queue()$/;"	f	class:Queue
Queue	src/queue.cpp	/^Queue::Queue(reference<const Queue> rhs)$/;"	f	class:Queue
SRC	unit_tests/Makefile	/^SRC=..\/src\/*.cpp $(FILE)$/;"	m
SortedList	sorted_list.hpp	/^class SortedList : public List {$/;"	c
SortedList	src/sorted_list.cpp	/^SortedList::SortedList() : List()$/;"	f	class:SortedList
SortedList	src/sorted_list.cpp	/^SortedList::SortedList(reference<const SortedList> sl)$/;"	f	class:SortedList
Sphere	sphere.hpp	/^class Sphere : public Circle {$/;"	c
Sphere	src/sphere.cpp	/^Sphere::Sphere(double radius) : Circle(radius)$/;"	f	class:Sphere
Stack	src/stack.cpp	/^Stack::Stack() : List()$/;"	f	class:Stack
Stack	src/stack.cpp	/^Stack::Stack(reference<const Stack> rhs)$/;"	f	class:Stack
Stack	stack.hpp	/^class Stack : public List {$/;"	c
append	src/list.cpp	/^auto List::append(int value) -> void$/;"	f	class:List	typeref:typename:void
back	src/queue.cpp	/^auto Queue::back() const -> int$/;"	f	class:Queue	typeref:typename:int
begin	src/list.cpp	/^[[nodiscard]] auto List::begin() const -> pointer<Node>$/;"	f	class:List	typeref:typename:pointer<Node>
bst	bst.hpp	/^class bst : public btree<T> {$/;"	c
btree	binary_tree.hpp	/^class btree {$/;"	c
btree	binary_tree_impl.hpp	/^btree<T>::btree()$/;"	f	class:btree
btree	binary_tree_impl.hpp	/^btree<T>::btree(ref<const btree> original)$/;"	f	class:btree
bubble_sort	src/functions.cpp	/^auto bubble_sort(ref<std::vector<int>> arr) -> void$/;"	f	typeref:typename:void
build	unit_tests/Makefile	/^build:$/;"	t
cbegin	src/list.cpp	/^[[nodiscard]] auto List::cbegin() const -> pointer<const Node>$/;"	f	class:List	typeref:typename:pointer<const Node>
children_count	binary_node_impl.hpp	/^auto BinaryNode<T>::children_count() const -> size_t$/;"	f	class:BinaryNode	typeref:typename:size_t
clear	src/list.cpp	/^auto List::clear() -> void$/;"	f	class:List	typeref:typename:void
clear	src/queue.cpp	/^auto Queue::clear() -> void$/;"	f	class:Queue	typeref:typename:void
copy	src/list.cpp	/^auto List::copy(reference<const List> rhs) -> void$/;"	f	class:List	typeref:typename:void
copy	src/queue.cpp	/^auto Queue::copy(reference<const Queue> rhs) -> void$/;"	f	class:Queue	typeref:typename:void
copy_branch	binary_node_impl.hpp	/^auto BinaryNode<T>::copy_branch(const ptr<const BinaryNode<T>> original) -> void$/;"	f	class:BinaryNode	typeref:typename:void
data	binary_node.hpp	/^	T data;$/;"	m	struct:BinaryNode	typeref:typename:T
data	fast_stack.hpp	/^	pointer<int> data;$/;"	m	class:fstack	typeref:typename:pointer<int>
dequeue	src/queue.cpp	/^auto Queue::dequeue() -> void$/;"	f	class:Queue	typeref:typename:void
display_binary	unit_tests/main2.cpp	/^auto display_binary(Stack bs) -> void$/;"	f	typeref:typename:void
empty	binary_tree_impl.hpp	/^[[nodiscard]] auto btree<T>::empty() const -> bool$/;"	f	class:btree	typeref:typename:bool
empty	src/fast_stack.cpp	/^auto fstack::empty() -> bool$/;"	f	class:fstack	typeref:typename:bool
empty	src/list.cpp	/^[[nodiscard]] auto List::empty() const -> bool$/;"	f	class:List	typeref:typename:bool
enqueue	src/queue.cpp	/^auto Queue::enqueue(int val) -> void$/;"	f	class:Queue	typeref:typename:void
find_max	bst_impl.hpp	/^auto bst<T>::find_max() const -> T$/;"	f	class:bst	typeref:typename:T
find_min	bst_impl.hpp	/^auto bst<T>::find_min() const -> T$/;"	f	class:bst	typeref:typename:T
format	unit_tests/Makefile	/^format:$/;"	t
front	src/queue.cpp	/^auto Queue::front() const -> int$/;"	f	class:Queue	typeref:typename:int
fstack	fast_stack.hpp	/^class fstack {$/;"	c
fstack	src/fast_stack.cpp	/^fstack::fstack()$/;"	f	class:fstack
get_area	src/circle.cpp	/^auto Circle::get_area() const -> double$/;"	f	class:Circle	typeref:typename:double
get_circumference	src/circle.cpp	/^auto Circle::get_circumference() const -> double$/;"	f	class:Circle	typeref:typename:double
get_diameter	src/circle.cpp	/^auto Circle::get_diameter() const -> double$/;"	f	class:Circle	typeref:typename:double
get_dimensions	src/cylinder.cpp	/^auto Cylinder::get_dimensions(double& radius, double& height) const -> void$/;"	f	class:Cylinder	typeref:typename:void
get_height	src/cylinder.cpp	/^auto Cylinder::get_height() const -> double$/;"	f	class:Cylinder	typeref:typename:double
get_radius	src/circle.cpp	/^auto Circle::get_radius() const -> double$/;"	f	class:Circle	typeref:typename:double
get_surface_area	src/cylinder.cpp	/^auto Cylinder::get_surface_area() const -> double$/;"	f	class:Cylinder	typeref:typename:double
get_surface_area	src/sphere.cpp	/^auto Sphere::get_surface_area() const -> double$/;"	f	class:Sphere	typeref:typename:double
get_volume	src/cylinder.cpp	/^auto Cylinder::get_volume() const -> double$/;"	f	class:Cylinder	typeref:typename:double
get_volume	src/sphere.cpp	/^auto Sphere::get_volume() const -> double$/;"	f	class:Sphere	typeref:typename:double
graph	binary_node_impl.hpp	/^auto BinaryNode<T>::graph(const int height) const -> void$/;"	f	class:BinaryNode	typeref:typename:void
graph	binary_tree_impl.hpp	/^auto btree<T>::graph() const -> void$/;"	f	class:btree	typeref:typename:void
height	binary_node_impl.hpp	/^auto BinaryNode<T>::height() const -> size_t$/;"	f	class:BinaryNode	typeref:typename:size_t
height	binary_tree_impl.hpp	/^auto btree<T>::height() const -> int$/;"	f	class:btree	typeref:typename:int
info	node.hpp	/^	int info;$/;"	m	struct:Node	typeref:typename:int
insert	bst_impl.hpp	/^auto bst<T>::insert(const T item) -> void$/;"	f	class:bst	typeref:typename:void
insert	src/sorted_list.cpp	/^auto SortedList::insert(int value) -> void$/;"	f	class:SortedList	typeref:typename:void
is_leaf	binary_node_impl.hpp	/^[[nodiscard]] auto BinaryNode<T>::is_leaf() const -> bool$/;"	f	class:BinaryNode	typeref:typename:bool
leaves	binary_tree_impl.hpp	/^auto btree<T>::leaves() const -> size_t$/;"	f	class:btree	typeref:typename:size_t
leaves_count	binary_node_impl.hpp	/^auto BinaryNode<T>::leaves_count() const -> size_t$/;"	f	class:BinaryNode	typeref:typename:size_t
left	binary_node.hpp	/^	ptr<BinaryNode> left;$/;"	m	struct:BinaryNode	typeref:typename:ptr<BinaryNode>
length	src/list.cpp	/^[[nodiscard]] auto List::length() const -> std::size_t$/;"	f	class:List	typeref:typename:std::size_t
link	node.hpp	/^	pointer<Node> link;$/;"	m	struct:Node	typeref:typename:pointer<Node>
m_front	queue.hpp	/^	pointer<Node>& m_front = m_head;$/;"	m	class:Queue	typeref:typename:pointer<Node> &
m_head	list.hpp	/^	pointer<Node> m_head;$/;"	m	class:List	typeref:typename:pointer<Node>
m_height	cylinder.hpp	/^	double m_height;$/;"	m	class:Cylinder	typeref:typename:double
m_radius	circle.hpp	/^	double m_radius;$/;"	m	class:Circle	typeref:typename:double
m_rear	queue.hpp	/^	pointer<Node> m_rear;$/;"	m	class:Queue	typeref:typename:pointer<Node>
m_size	list.hpp	/^	size_t m_size;$/;"	m	class:List	typeref:typename:size_t
m_top	stack.hpp	/^	pointer<Node>& m_top = m_head;$/;"	m	class:Stack	typeref:typename:pointer<Node> &
main	unit_tests/main.cpp	/^int main()$/;"	f	typeref:typename:int
main	unit_tests/main2.cpp	/^auto main() -> int$/;"	f	typeref:typename:int
main	unit_tests/unit_tests.cpp	/^auto main() -> int32_t$/;"	f	typeref:typename:int32_t
mean	src/functions.cpp	/^auto mean(ref<const std::vector<double>> arr) -> double$/;"	f	typeref:typename:double
mean	unit_tests/unit_tests.cpp	/^static auto mean(std::vector<double> array) -> double$/;"	f	typeref:typename:double	file:
operator +	src/circle.cpp	/^auto Circle::operator+(const Circle& rhs) const -> Circle$/;"	f	class:Circle	typeref:typename:Circle
operator +	src/cylinder.cpp	/^auto Cylinder::operator+(const Cylinder& rhs) -> Cylinder$/;"	f	class:Cylinder	typeref:typename:Cylinder
operator +	src/sphere.cpp	/^auto Sphere::operator+(Sphere const& rhs) const -> Sphere$/;"	f	class:Sphere	typeref:typename:Sphere
operator <<	src/circle.cpp	/^auto operator<<(std::ostream& lhs, const Circle& rhs) -> std::ostream&$/;"	f	typeref:typename:std::ostream &
operator <<	src/cylinder.cpp	/^auto operator<<(std::ostream& lhs, const Cylinder& rhs) -> std::ostream&$/;"	f	typeref:typename:std::ostream &
operator <<	src/list.cpp	/^auto operator<<(std::ostream& lhs, reference<const List> rhs) -> std::ostream&$/;"	f	typeref:typename:std::ostream &
operator <<	src/sphere.cpp	/^auto operator<<(std::ostream& lhs, Sphere const& rhs) -> std::ostream&$/;"	f	typeref:typename:std::ostream &
operator =	binary_tree_impl.hpp	/^auto btree<T>::operator = (ref<const btree> rhs) -> ref<const btree>$/;"	f	class:btree	typeref:typename:ref<const btree>
operator =	src/list.cpp	/^auto List::operator=(reference<const List> rhs) -> reference<const List>$/;"	f	class:List	typeref:typename:reference<const List>
operator =	src/queue.cpp	/^auto Queue::operator=(reference<const Queue> rhs) -> reference<const Queue>$/;"	f	class:Queue	typeref:typename:reference<const Queue>
operator =	src/stack.cpp	/^auto Stack::operator=(reference<const Stack> rhs) -> reference<Stack>$/;"	f	class:Stack	typeref:typename:reference<Stack>
operator ==	src/circle.cpp	/^auto Circle::operator==(const Circle& rhs) const -> bool$/;"	f	class:Circle	typeref:typename:bool
operator ==	src/cylinder.cpp	/^auto Cylinder::operator==(const Cylinder& rhs) -> bool$/;"	f	class:Cylinder	typeref:typename:bool
operator ==	src/queue.cpp	/^auto Queue::operator==(reference<const Queue> rhs) -> bool$/;"	f	class:Queue	typeref:typename:bool
operator ==	src/sphere.cpp	/^auto Sphere::operator==(Sphere const& rhs) const -> bool$/;"	f	class:Sphere	typeref:typename:bool
operator >>	src/circle.cpp	/^auto operator>>(std::istream& lhs, Circle& rhs) -> std::istream&$/;"	f	typeref:typename:std::istream &
operator >>	src/cylinder.cpp	/^auto operator>>(std::istream& lhs, Cylinder& rhs) -> std::istream&$/;"	f	typeref:typename:std::istream &
operator >>	src/list.cpp	/^auto operator>>(std::istream& lhs, reference<List> rhs) -> std::istream&$/;"	f	typeref:typename:std::istream &
operator >>	src/sphere.cpp	/^auto operator>>(std::istream& lhs, Sphere& rhs) -> std::istream&$/;"	f	typeref:typename:std::istream &
pointer	data.hpp	/^template <typename T> using pointer = T*;$/;"	t	typeref:typename:T *
pop	src/fast_stack.cpp	/^auto fstack::pop() -> void$/;"	f	class:fstack	typeref:typename:void
pop	src/stack.cpp	/^auto Stack::pop() -> std::optional<int>$/;"	f	class:Stack	typeref:typename:std::optional<int>
prepend	src/list.cpp	/^auto List::prepend(int value) -> void$/;"	f	class:List	typeref:typename:void
print	src/circle.cpp	/^auto Circle::print() const -> void$/;"	f	class:Circle	typeref:typename:void
print	src/cylinder.cpp	/^auto Cylinder::print() const -> void$/;"	f	class:Cylinder	typeref:typename:void
print	src/list.cpp	/^auto List::print() const -> void$/;"	f	class:List	typeref:typename:void
print	unit_tests/unit_tests.cpp	/^auto print(auto const x) -> void$/;"	f	typeref:typename:void
print_ascending	binary_tree_impl.hpp	/^auto btree<T>::print_ascending() const -> void$/;"	f	class:btree	typeref:typename:void
print_descending	binary_tree_impl.hpp	/^auto btree<T>::print_descending() const -> void$/;"	f	class:btree	typeref:typename:void
print_inorder	binary_node_impl.hpp	/^auto BinaryNode<T>::print_inorder() const -> void$/;"	f	class:BinaryNode	typeref:typename:void
print_preorder	binary_node_impl.hpp	/^auto BinaryNode<T>::print_preorder() const -> void$/;"	f	class:BinaryNode	typeref:typename:void
println	unit_tests/unit_tests.cpp	/^auto println(auto const x) -> void$/;"	f	typeref:typename:void
ptr	binary_node.hpp	/^using ptr = T*;$/;"	t	typeref:typename:T *
ptr	binary_tree.hpp	/^using ptr = T*;$/;"	t	typeref:typename:T *
push	src/fast_stack.cpp	/^auto fstack::push(int val) -> void$/;"	f	class:fstack	typeref:typename:void
push	src/stack.cpp	/^auto Stack::push(int value) -> void$/;"	f	class:Stack	typeref:typename:void
read_decimal	unit_tests/main2.cpp	/^auto read_decimal() -> int$/;"	f	typeref:typename:int
ref	binary_node.hpp	/^using ref = T&;$/;"	t	typeref:typename:T &
ref	binary_tree.hpp	/^using ref = T&; \/\/ nicer way to type reference variables$/;"	t	typeref:typename:T &
ref	src/functions.cpp	/^using ref = T&;$/;"	t	typeref:typename:T &	file:
reference	data.hpp	/^template <typename T> using reference = T&;$/;"	t	typeref:typename:T &
remove	bst_impl.hpp	/^auto bst<T>::remove(const T item) -> void$/;"	f	class:bst	typeref:typename:void
remove	src/list.cpp	/^auto List::remove(int value) -> void$/;"	f	class:List	typeref:typename:void
remove_from_tree	bst_impl.hpp	/^auto bst<T>::remove_from_tree(ptr<const BinaryNode<T>> ptr) -> void$/;"	f	class:bst	typeref:typename:void
repeated_division	unit_tests/main2.cpp	/^auto repeated_division(int decimal) -> Stack$/;"	f	typeref:typename:Stack
right	binary_node.hpp	/^	ptr<BinaryNode> right;$/;"	m	struct:BinaryNode	typeref:typename:ptr<BinaryNode>
root	binary_tree.hpp	/^	ptr<BinaryNode<T>> root;$/;"	m	class:btree	typeref:typename:ptr<BinaryNode<T>>
run	unit_tests/Makefile	/^run: build$/;"	t
search	bst_impl.hpp	/^auto bst<T>::search(T value) const -> const ptr<const BinaryNode<T>>$/;"	f	class:bst	typeref:typename:const ptr<const BinaryNode<T>>
search	src/list.cpp	/^[[nodiscard]] auto List::search(int value) const -> bool$/;"	f	class:List	typeref:typename:bool
search	src/sorted_list.cpp	/^[[nodiscard]] auto SortedList::search(int value) const -> bool$/;"	f	class:SortedList	typeref:typename:bool
selection_sort	src/functions.cpp	/^auto selection_sort(ref<std::vector<int>> arr) -> void$/;"	f	typeref:typename:void
set_dimensions	src/cylinder.cpp	/^auto Cylinder::set_dimensions(double radius, double height) -> void$/;"	f	class:Cylinder	typeref:typename:void
set_height	src/cylinder.cpp	/^auto Cylinder::set_height(double height) -> void$/;"	f	class:Cylinder	typeref:typename:void
set_radius	src/circle.cpp	/^auto Circle::set_radius(double radius) -> void$/;"	f	class:Circle	typeref:typename:void
size	fast_stack.hpp	/^	sz size;$/;"	m	class:fstack	typeref:typename:sz
size_t	binary_node.hpp	/^using size_t = std::size_t;$/;"	t	typeref:typename:std::size_t
size_t	binary_tree.hpp	/^using size_t = std::size_t;$/;"	t	typeref:typename:std::size_t
sz	fast_stack.hpp	/^using sz = std::size_t;$/;"	t	typeref:typename:std::size_t
top	src/fast_stack.cpp	/^auto fstack::top() -> int$/;"	f	class:fstack	typeref:typename:int
top	src/stack.cpp	/^[[nodiscard]] auto Stack::top() const -> std::optional<int>$/;"	f	class:Stack	typeref:typename:std::optional<int>
~Cylinder	src/cylinder.cpp	/^Cylinder::~Cylinder()$/;"	f	class:Cylinder
~List	src/list.cpp	/^List::~List()$/;"	f	class:List
~Queue	src/queue.cpp	/^Queue::~Queue()$/;"	f	class:Queue
~SortedList	src/sorted_list.cpp	/^SortedList::~SortedList()$/;"	f	class:SortedList
~Sphere	src/sphere.cpp	/^Sphere::~Sphere()$/;"	f	class:Sphere
~Stack	src/stack.cpp	/^Stack::~Stack()$/;"	f	class:Stack
~btree	binary_tree_impl.hpp	/^btree<T>::~btree()$/;"	f	class:btree
~fstack	src/fast_stack.cpp	/^fstack::~fstack()$/;"	f	class:fstack
